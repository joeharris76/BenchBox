"""TPC-H qgen wrapper utility.

This module provides a wrapper class for interacting with the TPC-H C qgen tool,
including output parsing, comparison utilities, and error handling.

Copyright 2026 Joe Harris / BenchBox Project

Licensed under the MIT License. See LICENSE file in the project root for details.
"""

import logging
import os
import re
import subprocess
import time
from collections.abc import Generator
from contextlib import contextmanager
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Optional

try:
    import sqlglot  # type: ignore[import-untyped]
    from sqlglot import parse_one, transpile  # type: ignore[import-untyped]
    from sqlglot.errors import ParseError  # type: ignore[import-untyped]

    SQLGLOT_AVAILABLE = True
except ImportError:
    sqlglot = None  # type: ignore[assignment]
    parse_one = None  # type: ignore[assignment]
    transpile = None  # type: ignore[assignment]
    ParseError = Exception
    SQLGLOT_AVAILABLE = False

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class QgenError(Exception):
    """Base exception for qgen-related errors."""


class QgenCompilationError(QgenError):
    """Exception raised when qgen compilation fails."""


class QgenExecutionError(QgenError):
    """Exception raised when qgen execution fails."""


class QgenParsingError(QgenError):
    """Exception raised when qgen output parsing fails."""


class QueryComparisonError(QgenError):
    """Exception raised when query comparison fails."""


@dataclass
class QgenQuery:
    """Container for a TPC-H query generated by qgen."""

    query_id: int
    raw_query: str
    normalized_query: str = ""
    parameters: dict[str, Any] = field(default_factory=dict)
    generation_time: float = 0.0
    parse_tree: Optional[Any] = None
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class QueryComparisonResult:
    """Container for query comparison results."""

    query_id: int
    python_query: str
    c_query: str
    similarity_score: float = 0.0
    structure_match: bool = False
    parameter_match: bool = False
    semantic_match: bool = False
    differences: list[str] = field(default_factory=list)
    python_errors: list[str] = field(default_factory=list)
    c_errors: list[str] = field(default_factory=list)
    comparison_metadata: dict[str, Any] = field(default_factory=dict)


class ComparisonLevel(Enum):
    """Levels of query comparison."""

    BASIC = "basic"
    STRUCTURAL = "structural"
    SEMANTIC = "semantic"
    PARAMETER = "parameter"


class QGenWrapper:
    """Wrapper class for TPC-H qgen C tool interaction."""

    def __init__(
        self,
        tpch_tools_path: Optional[Path] = None,
        force_compile: bool = False,
        verbose: bool = False,
        timeout: int = 60,
    ):
        """Initialize the qgen wrapper.

        Args:
            tpch_tools_path: Path to TPC-H tools directory
            force_compile: Force recompilation of tools
            verbose: Enable verbose logging
            timeout: Timeout for qgen operations in seconds
        """
        self.verbose = verbose
        self.timeout = timeout
        self.force_compile = force_compile

        # Set up paths
        if tpch_tools_path is None:
            project_root = Path(__file__).parent.parent.parent
            tpch_tools_path = project_root / "_sources" / "tpc-h" / "dbgen"

        self.tools_path = Path(tpch_tools_path)
        self.qgen_binary = self.tools_path / "qgen"
        self.dbgen_binary = self.tools_path / "dbgen"

        # Track tool availability
        self._is_available = None
        self._last_check_time = 0

        # Initialize if tools are available
        if self.check_availability():
            self._ensure_tools_ready()

    def check_availability(self, force_check: bool = False) -> bool:
        """Check if TPC-H tools are available.

        Args:
            force_check: Force a fresh availability check

        Returns:
            True if tools are available and functional
        """
        current_time = time.time()

        # Use cached result if recent
        if not force_check and self._is_available is not None and current_time - self._last_check_time < 30:
            return self._is_available

        self._last_check_time = current_time

        try:
            # Check if tools directory exists
            if not self.tools_path.exists():
                if self.verbose:
                    logger.warning(f"TPC-H tools directory not found: {self.tools_path}")
                self._is_available = False
                return False

            # Check for required source files
            required_files = [
                "qgen.c",
                "makefile",
                "tpcd.h",
                "dss.h",
                "varsub.c",
                "rnd.c",
            ]

            missing_files = []
            for file in required_files:
                if not (self.tools_path / file).exists():
                    missing_files.append(file)

            if missing_files:
                if self.verbose:
                    logger.warning(f"Missing TPC-H source files: {missing_files}")
                self._is_available = False
                return False

            # Check if qgen binary exists or can be compiled
            if not self.qgen_binary.exists() or self.force_compile:
                try:
                    self._compile_tools()
                except QgenCompilationError:
                    self._is_available = False
                    return False

            # Test basic functionality
            test_result = self._test_qgen_functionality()
            self._is_available = test_result
            return test_result

        except Exception as e:
            if self.verbose:
                logger.error(f"Error checking TPC-H tools availability: {e}")
            self._is_available = False
            return False

    def _ensure_tools_ready(self) -> None:
        """Ensure TPC-H tools are compiled and ready."""
        if not self.qgen_binary.exists() or self.force_compile:
            self._compile_tools()

    def _compile_tools(self) -> None:
        """Compile TPC-H tools."""
        if self.verbose:
            logger.info(f"Compiling TPC-H tools in {self.tools_path}")

        try:
            with self._change_directory(self.tools_path):
                # Clean previous build
                self._run_make_command("clean", check=False)

                # Compile qgen
                self._run_make_command("qgen")

                # Verify compilation succeeded
                if not self.qgen_binary.exists():
                    raise QgenCompilationError("qgen binary not found after compilation")

                # Make binary executable
                os.chmod(self.qgen_binary, 0o755)

                if self.verbose:
                    logger.info("TPC-H tools compiled successfully")

        except subprocess.CalledProcessError as e:
            error_msg = f"TPC-H compilation failed: {e}"
            if hasattr(e, "stderr") and e.stderr:
                error_msg += f"\nSTDERR: {e.stderr}"
            raise QgenCompilationError(error_msg)
        except Exception as e:
            raise QgenCompilationError(f"Unexpected compilation error: {e}")

    def _run_make_command(self, target: str, check: bool = True) -> subprocess.CompletedProcess:
        """Run a make command in the tools directory.

        Args:
            target: Make target to run
            check: Whether to check return code

        Returns:
            CompletedProcess result
        """
        cmd = ["make", target]

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=self.timeout)

        if check and result.returncode != 0:
            error_msg = f"Make {target} failed (return code {result.returncode})"
            if result.stderr:
                error_msg += f"\nSTDERR: {result.stderr}"
            if result.stdout:
                error_msg += f"\nSTDOUT: {result.stdout}"
            raise subprocess.CalledProcessError(result.returncode, cmd, error_msg)

        return result

    @contextmanager
    def _change_directory(self, path: Path) -> Generator[None, None, None]:
        """Context manager for changing directory."""
        old_cwd = os.getcwd()
        try:
            os.chdir(path)
            yield
        finally:
            os.chdir(old_cwd)

    def _test_qgen_functionality(self) -> bool:
        """Test basic qgen functionality."""
        try:
            # Try to get help output
            result = subprocess.run(
                [str(self.qgen_binary), "-h"],
                capture_output=True,
                text=True,
                timeout=10,
            )

            # qgen might return non-zero for help, but should produce output
            return bool(result.stdout or result.stderr)

        except Exception as e:
            if self.verbose:
                logger.error(f"qgen functionality test failed: {e}")
            return False

    def generate_query(
        self,
        query_id: int,
        seed: Optional[int] = None,
        dialect: str = "ansi",
        scale_factor: float = 1.0,
    ) -> QgenQuery:
        """Generate a TPC-H query using qgen.

        Args:
            query_id: Query number (1-22)
            seed: Random seed for parameterization
            dialect: SQL dialect (not used by TPC-H qgen)
            scale_factor: Scale factor (not used by TPC-H qgen)

        Returns:
            QgenQuery object containing the generated query
        """
        if not self.check_availability():
            raise QgenExecutionError("TPC-H qgen tools not available")

        if not 1 <= query_id <= 22:
            raise ValueError(f"Invalid query ID: {query_id}. Must be between 1 and 22.")

        start_time = time.time()

        try:
            # Build command
            cmd = [str(self.qgen_binary), "-s", str(query_id)]
            if seed is not None:
                cmd.extend(["-r", str(seed)])

            # Execute qgen
            with self._change_directory(self.tools_path):
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=self.timeout)

            generation_time = time.time() - start_time

            if result.returncode != 0:
                error_msg = f"qgen execution failed for query {query_id}"
                if result.stderr:
                    error_msg += f": {result.stderr}"
                raise QgenExecutionError(error_msg)

            # Parse output
            query = self._parse_qgen_output(result.stdout, query_id)
            query.generation_time = generation_time

            if self.verbose:
                logger.info(f"Generated query {query_id} in {generation_time:.3f}s")

            return query

        except subprocess.TimeoutExpired:
            raise QgenExecutionError(f"qgen timed out for query {query_id}")
        except Exception as e:
            raise QgenExecutionError(f"Failed to generate query {query_id}: {e}")

    def _parse_qgen_output(self, output: str, query_id: int) -> QgenQuery:
        """Parse qgen output into structured format.

        Args:
            output: Raw qgen output
            query_id: Query ID for context

        Returns:
            QgenQuery object
        """
        lines = output.strip().split("\n")

        # Extract query and metadata
        query_lines = []
        parameters = {}
        errors = []
        warnings = []
        metadata = {}

        for line in lines:
            line = line.strip()

            if not line:
                continue

            # Check for comment lines with parameters
            if line.startswith("--"):
                # Try to extract parameter information
                param_match = re.match(r"--\s*(\w+)\s*[:=]\s*(.+)", line)
                if param_match:
                    param_name, param_value = param_match.groups()
                    parameters[param_name] = param_value.strip()
                continue

            # Check for error/warning indicators
            if any(keyword in line.lower() for keyword in ["error", "fail", "exception"]):
                errors.append(line)
                continue

            if any(keyword in line.lower() for keyword in ["warning", "warn"]):
                warnings.append(line)
                continue

            # Assume everything else is part of the query
            query_lines.append(line)

        raw_query = "\n".join(query_lines)

        # query object
        query = QgenQuery(
            query_id=query_id,
            raw_query=raw_query,
            parameters=parameters,
            errors=errors,
            warnings=warnings,
            metadata=metadata,
        )

        # Normalize query
        try:
            query.normalized_query = self._normalize_query(raw_query)
        except Exception as e:
            errors.append(f"Query normalization failed: {e}")
            query.normalized_query = raw_query

        # Parse query if sqlglot is available
        if SQLGLOT_AVAILABLE:
            try:
                query.parse_tree = parse_one(raw_query, dialect="postgres")
            except Exception as e:
                warnings.append(f"Query parsing failed: {e}")

        return query

    def _normalize_query(self, query: str) -> str:
        """Normalize SQL query for comparison.

        Args:
            query: Raw SQL query

        Returns:
            Normalized query string
        """
        if SQLGLOT_AVAILABLE:
            try:
                parsed = parse_one(query, dialect="postgres")
                return parsed.sql(dialect="postgres", pretty=True)
            except Exception:
                pass

        # Basic normalization
        query = re.sub(r"\s+", " ", query)
        query = query.strip()

        # Normalize common SQL keywords
        keywords = [
            "SELECT",
            "FROM",
            "WHERE",
            "GROUP BY",
            "ORDER BY",
            "HAVING",
            "LIMIT",
            "OFFSET",
            "JOIN",
            "INNER JOIN",
            "LEFT JOIN",
            "RIGHT JOIN",
            "FULL JOIN",
            "UNION",
            "INTERSECT",
            "EXCEPT",
            "WITH",
            "AS",
        ]

        for keyword in keywords:
            pattern = r"\b" + re.escape(keyword) + r"\b"
            query = re.sub(pattern, keyword, query, flags=re.IGNORECASE)

        return query

    def generate_all_queries(self, seed: Optional[int] = None, dialect: str = "ansi") -> list[QgenQuery]:
        """Generate all TPC-H queries (1-22).

        Args:
            seed: Random seed for parameterization
            dialect: SQL dialect

        Returns:
            List of QgenQuery objects
        """
        if not self.check_availability():
            raise QgenExecutionError("TPC-H qgen tools not available")

        queries = []

        for query_id in range(1, 23):
            try:
                query = self.generate_query(query_id, seed, dialect)
                queries.append(query)
            except Exception as e:
                logger.warning(f"Failed to generate query {query_id}: {e}")
                # error query object
                error_query = QgenQuery(query_id=query_id, raw_query="", errors=[str(e)])
                queries.append(error_query)

        return queries

    def compare_with_python_query(
        self,
        query_id: int,
        python_query: str,
        seed: Optional[int] = None,
        comparison_level: ComparisonLevel = ComparisonLevel.STRUCTURAL,
    ) -> QueryComparisonResult:
        """Compare a Python-generated query with C qgen output.

        Args:
            query_id: Query ID
            python_query: Query from Python implementation
            seed: Random seed for C query generation
            comparison_level: Level of comparison to perform

        Returns:
            QueryComparisonResult object
        """
        # Generate C query
        try:
            c_query_obj = self.generate_query(query_id, seed)
            c_query = c_query_obj.raw_query
            c_errors = c_query_obj.errors
        except Exception as e:
            c_query = ""
            c_errors = [str(e)]

        # comparison result
        result = QueryComparisonResult(
            query_id=query_id,
            python_query=python_query,
            c_query=c_query,
            c_errors=c_errors,
        )

        # Perform comparison if both queries are available
        if python_query and c_query:
            try:
                self._perform_comparison(result, comparison_level)
            except Exception as e:
                result.python_errors.append(f"Comparison failed: {e}")

        return result

    def _perform_comparison(self, result: QueryComparisonResult, comparison_level: ComparisonLevel) -> None:
        """Perform the actual query comparison.

        Args:
            result: QueryComparisonResult to populate
            comparison_level: Level of comparison to perform
        """
        # Normalize queries
        norm_python = self._normalize_query(result.python_query)
        norm_c = self._normalize_query(result.c_query)

        # Calculate similarity
        result.similarity_score = self._calculate_similarity(norm_python, norm_c)

        # Identify differences
        result.differences = self._identify_differences(norm_python, norm_c)

        # Structural comparison
        if comparison_level in [ComparisonLevel.STRUCTURAL, ComparisonLevel.SEMANTIC]:
            result.structure_match = self._compare_structure(norm_python, norm_c)

        # Semantic comparison
        if comparison_level == ComparisonLevel.SEMANTIC:
            result.semantic_match = self._compare_semantics(norm_python, norm_c)

        # Parameter comparison (if available)
        if comparison_level == ComparisonLevel.PARAMETER:
            result.parameter_match = self._compare_parameters(norm_python, norm_c)

    def _calculate_similarity(self, query1: str, query2: str) -> float:
        """Calculate similarity score between two queries."""
        import difflib

        return difflib.SequenceMatcher(None, query1, query2).ratio()

    def _identify_differences(self, query1: str, query2: str) -> list[str]:
        """Identify specific differences between queries."""
        import difflib

        differences = []
        diff = difflib.unified_diff(
            query1.splitlines(),
            query2.splitlines(),
            fromfile="python",
            tofile="c",
            lineterm="",
        )

        for line in diff:
            if line.startswith(("+", "-")):
                differences.append(line)

        return differences

    def _compare_structure(self, query1: str, query2: str) -> bool:
        """Compare structural elements of queries."""
        if SQLGLOT_AVAILABLE:
            try:
                # Parse both queries and compare AST structure
                parsed1 = parse_one(query1, dialect="postgres")
                parsed2 = parse_one(query2, dialect="postgres")

                # Simple structural comparison
                return type(parsed1) == type(parsed2)

            except Exception:
                pass

        # Fallback to text-based structural comparison
        return self._compare_text_structure(query1, query2)

    def _compare_text_structure(self, query1: str, query2: str) -> bool:
        """Compare text-based structure of queries."""
        # Extract main SQL clauses
        clauses1 = self._extract_sql_clauses(query1)
        clauses2 = self._extract_sql_clauses(query2)

        # Check if same clauses are present
        return set(clauses1.keys()) == set(clauses2.keys())

    def _extract_sql_clauses(self, query: str) -> dict[str, str]:
        """Extract main SQL clauses from query."""
        clauses = {}

        clause_patterns = {
            "SELECT": r"SELECT\s+(.+?)(?=\s+FROM|\s*$)",
            "FROM": r"FROM\s+(.+?)(?=\s+WHERE|\s+GROUP\s+BY|\s+ORDER\s+BY|\s+LIMIT|\s*$)",
            "WHERE": r"WHERE\s+(.+?)(?=\s+GROUP\s+BY|\s+ORDER\s+BY|\s+LIMIT|\s*$)",
            "GROUP_BY": r"GROUP\s+BY\s+(.+?)(?=\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s*$)",
            "HAVING": r"HAVING\s+(.+?)(?=\s+ORDER\s+BY|\s+LIMIT|\s*$)",
            "ORDER_BY": r"ORDER\s+BY\s+(.+?)(?=\s+LIMIT|\s*$)",
            "LIMIT": r"LIMIT\s+(.+?)(?=\s*$)",
        }

        for clause_name, pattern in clause_patterns.items():
            match = re.search(pattern, query, re.IGNORECASE | re.DOTALL)
            if match:
                clauses[clause_name] = match.group(1).strip()

        return clauses

    def _compare_semantics(self, query1: str, query2: str) -> bool:
        """Compare semantic meaning of queries."""
        # This is a simplified semantic comparison
        # In a full implementation, you might:
        # 1. Compare execution plans
        # 2. Use semantic analysis tools
        # 3. Compare query results on sample data

        # For now, return true if structurally similar
        return self._compare_structure(query1, query2)

    def _compare_parameters(self, query1: str, query2: str) -> bool:
        """Compare parameter usage in queries."""
        # Extract parameter patterns
        param_pattern = r":\w+|\$\d+|\?\d*"

        params1 = set(re.findall(param_pattern, query1))
        params2 = set(re.findall(param_pattern, query2))

        return params1 == params2

    def generate_comparison_report(
        self,
        comparisons: list[QueryComparisonResult],
        output_file: Optional[Path] = None,
    ) -> str:
        """Generate a comprehensive comparison report.

        Args:
            comparisons: List of query comparison results
            output_file: Optional file to write report to

        Returns:
            Report as string
        """
        report_lines = []

        # Header
        report_lines.append("TPC-H Query Comparison Report")
        report_lines.append("=" * 50)
        report_lines.append("")

        # Summary statistics
        total_queries = len(comparisons)
        successful_comparisons = sum(1 for c in comparisons if c.c_query and c.python_query)
        structure_matches = sum(1 for c in comparisons if c.structure_match)
        semantic_matches = sum(1 for c in comparisons if c.semantic_match)

        if successful_comparisons > 0:
            avg_similarity = (
                sum(c.similarity_score for c in comparisons if c.similarity_score > 0) / successful_comparisons
            )
        else:
            avg_similarity = 0

        report_lines.append(f"Total Queries: {total_queries}")
        report_lines.append(f"Successful Comparisons: {successful_comparisons}")
        report_lines.append(f"Structure Matches: {structure_matches} ({structure_matches / total_queries * 100:.1f}%)")
        report_lines.append(f"Semantic Matches: {semantic_matches} ({semantic_matches / total_queries * 100:.1f}%)")
        report_lines.append(f"Average Similarity: {avg_similarity:.3f}")
        report_lines.append("")

        # Detailed results
        report_lines.append("Detailed Results:")
        report_lines.append("-" * 20)

        for comp in comparisons:
            report_lines.append(f"Query {comp.query_id}:")
            report_lines.append(f"  Similarity Score: {comp.similarity_score:.3f}")
            report_lines.append(f"  Structure Match: {comp.structure_match}")
            report_lines.append(f"  Semantic Match: {comp.semantic_match}")
            report_lines.append(f"  Parameter Match: {comp.parameter_match}")

            if comp.differences:
                report_lines.append(f"  Differences: {len(comp.differences)}")
                for diff in comp.differences[:3]:  # Show first 3 differences
                    report_lines.append(f"    {diff}")
                if len(comp.differences) > 3:
                    report_lines.append(f"    ... and {len(comp.differences) - 3} more")

            if comp.python_errors or comp.c_errors:
                report_lines.append(f"  Errors: Python({len(comp.python_errors)}), C({len(comp.c_errors)})")
                for error in comp.python_errors[:2]:
                    report_lines.append(f"    Python: {error}")
                for error in comp.c_errors[:2]:
                    report_lines.append(f"    C: {error}")

            report_lines.append("")

        report = "\n".join(report_lines)

        # Write to file if requested
        if output_file:
            output_file.write_text(report)
            logger.info(f"Comparison report written to {output_file}")

        return report

    def cleanup(self) -> None:
        """Clean up temporary files and resources."""
        # Clean up any temporary files created during operation
        try:
            # Strip temporary query files
            temp_files = self.tools_path.glob("*.tmp")
            for temp_file in temp_files:
                temp_file.unlink()

            # Clean build artifacts if requested
            if self.force_compile:
                with self._change_directory(self.tools_path):
                    self._run_make_command("clean", check=False)

        except Exception as e:
            if self.verbose:
                logger.warning(f"Cleanup failed: {e}")

    def __enter__(self):
        """Context manager entry."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.cleanup()


# Utility functions
def create_qgen_wrapper(tpch_tools_path: Optional[Path] = None, verbose: bool = False) -> QGenWrapper:
    """Create a qgen wrapper with error handling.

    Args:
        tpch_tools_path: Path to TPC-H tools directory
        verbose: Enable verbose logging

    Returns:
        QGenWrapper instance

    Raises:
        QgenError: If wrapper creation fails
    """
    try:
        wrapper = QGenWrapper(tpch_tools_path=tpch_tools_path, verbose=verbose)

        if not wrapper.check_availability():
            raise QgenError("TPC-H C tools not available")

        return wrapper

    except Exception as e:
        raise QgenError(f"Failed to create qgen wrapper: {e}")


def compare_query_implementations(
    python_query: str,
    query_id: int,
    tpch_tools_path: Optional[Path] = None,
    seed: Optional[int] = None,
) -> QueryComparisonResult:
    """Compare Python and C query implementations.

    Args:
        python_query: Query from Python implementation
        query_id: Query ID
        tpch_tools_path: Path to TPC-H tools directory
        seed: Random seed for C query generation

    Returns:
        QueryComparisonResult object
    """
    with create_qgen_wrapper(tpch_tools_path) as wrapper:
        return wrapper.compare_with_python_query(query_id=query_id, python_query=python_query, seed=seed)


def batch_compare_queries(
    python_queries: dict[int, str],
    tpch_tools_path: Optional[Path] = None,
    seed: Optional[int] = None,
) -> list[QueryComparisonResult]:
    """Compare multiple Python queries with C implementations.

    Args:
        python_queries: Dictionary mapping query IDs to Python queries
        tpch_tools_path: Path to TPC-H tools directory
        seed: Random seed for C query generation

    Returns:
        List of QueryComparisonResult objects
    """
    results = []

    with create_qgen_wrapper(tpch_tools_path) as wrapper:
        for query_id, python_query in python_queries.items():
            try:
                result = wrapper.compare_with_python_query(query_id=query_id, python_query=python_query, seed=seed)
                results.append(result)
            except Exception as e:
                # error result
                error_result = QueryComparisonResult(
                    query_id=query_id,
                    python_query=python_query,
                    c_query="",
                    python_errors=[str(e)],
                )
                results.append(error_result)

    return results
